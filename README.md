## 什么是数据结构和算法

* 什么是 **数据结构和算法**呢？
  * 如果我们只是想了解语言的**应用层面**，那么数据结构和算法显得没有那么重要。
  * 但是如果我们希望了解语言的**设计层面**，那么数据结构和算法就非常的重要

* 什么时候会想学习数据结构和算法呢？

  * 面试时被问到的时候
  * 工作一两年之后。

* 我们分开来理解什么是数据结构和算法？

  * 什么是数据结构
    * 数据结构是数据对象，以及存在于该对象的实例和组成实例的数据元素之间的各种联系。这些联系可以通过定义相关的函数来给出。--- 《数据结构、算法与应用》
    * 数据结构就是 在计算机中，存储和组织数据的方式

  * 什么是算法
    * 算法（Algorithm）的认识
      * 在之前的学习中，我们可能学习过几种排序算法。并且知道，不同的算法，执行效率是不一样的
      * 也就是说**解决问题**的过程中，不仅仅数据的存储方式会影响效率，算法的优劣也会影响效率
    * 算法的定义
      * 一个有限的指令集，每条指令的描述不依赖于语言
      * 接受一些输入（有些情况下不需要输入）
      * 产生输出
      * 一定在有限步骤之后终止
    * 算法通俗理解：
      * Algorithm这个单词本意就是解决问题的办法/步骤逻辑
      * 数据结构的实现，离不开算法

### 一、数据结构

#### 栈结构

----



* 栈（stock）是一种受限的线性表，**后进先出（LIFO）**

  * 其限制是仅允许在**表的一端**进行插入和删除运算。这一端被称为**栈顶**，相对地，把另外一段称为**栈底**。

  * LIFO（last in first out）表示就是后进入的元素，第一个弹出栈空间。类似于自动餐托盘，最后放在的托盘，往往先把拿出去使用。

  * 向一个栈插入新元素又称作**进栈、入栈或压栈，它是把新元素放到栈顶元素的上面，使之成为新的栈顶元素

  * 从一个栈删除元素又称作**出栈或退栈**，它是把栈顶元素删除掉，使其相邻的元素成为新的栈顶元素

#### 栈结构的实现

----

* 实现栈结构有两种比较常见的方式：
  * 基于数组实现
  * 基于链表实现
* 什么是链表？
  * 也是一种数据结构，并且JavaScirpt中并没有自带链表结构

* 栈常见有哪些操作呢？
  * push(element):添加一个新元素到栈顶位置
  * pop(): 移除栈顶的元素，同时返回被移除的元素
  * peek(): 返回栈顶的元素，不对栈做任何修改（这个方法不会移除栈顶的元素，仅仅返回它）
  * isEmpty(): 如果栈里没有任何元素就返回ture，否则返回false
  * size():返回栈里的元素个数。这个方法和数组的length属性很类似
  * toString():将栈结构的内容以字符形式返回

##### 十进制转二进

1. 为什么需要十进制转二进制？
   1. 现实生活中，我们主要使用十进制
   2. 在计算科学中，二进制非常重要，因为计算机里所有内容都是用二进制数字表示的(0和1)
   3. 没有十进制和二进制互相转化的能力，与计算机交流就很困难

2. 如何实现十进制转二进制？

   1. 要把十进制转化成二进制，我们可以将该十进制数字和2整除，直到结果是0为止

   2. 举个例子：要把十进制的数字100转化成二进制的数字：

      ~~~~javas
      除以2    倍数   余数
      100/2 -> 50 -> 0
      50/2  -> 25 -> 0
      25/2  -> 12 -> 1
      12/2  -> 6  -> 0
      6/2   -> 3  -> 0
      3/2   -> 1  -> 1
      1/2   -> 0  -> 1
      
      所以十进制的100转成二进制的数字为: 1100100
      ~~~~

### 二、队列结构

----

##### 1. 认识队列

* 受限的线性结构：
  * 我们已经学习了一种**受限的线性结构**：栈结构
  * 并且已经知道这种受限的数据结构对于解决某些特定问题，会有**特别的效果**

* 队列（Queue），它是一种受限的线性表，**先进先出**（FIFO First In First Out）
  * 受限之处在于它只允许在表的**前端**（front）进行删除操作
  * 而在表的**后端**（rear）进行插入操作

* 生活中类似的队列结构
  * 生活中类似队列的场景就是非常多了
  * 比如在**电影院、商场**，甚至是**厕所**排队
  * 优先排队的人，优先处理（买票，结账，WC）

##### 2.队列的应用

##### 3.队列类的创建

* 队列结构的实现

  * 基于数组实现
  * 基于链表实现

* 队列的常见操作

  * enqueue(element): 向队列尾部添加一个（或多个）新的项。

  * dequeue(): 移除队列的第一（即排在队列最前面的）项，并返回被移出的元素

  * front(): 返回队列的第一个元素 （类似栈中的peek方法）

  * isEmpty(): 如果队列中不包含任何元素，返回true，否则返回false

  * size(): 返回队列包含的元素个数，与数组的length属性类似

  * toString(): 将队列中的内容，转成字符串形式

~~~~javascript
lili haha limei lucy tom
lucy tom lili haha
haha lucy tom
haha lucy
lucy
~~~~

* 优先级队列的实现
  * 实现优先级队列相对队列主要有两方面需要考虑：
    * 封装元素和优先级放在一起（可以封装一个新的构造函数）
    * 添加元素时，将新插入元素的优先级和队列中已经存在的元素优先级进行比较，以获得自己正确的位置

### 三、链表

----

> 链表和数组一样，可以用于**存储一些列的元素**，但是链表和数组的**实现机制完全不同**

#### 1. 数组的缺点

> 要存储多个元素，数组（或称为列表）可能是最常用的数据结构
>
> 几乎每种编程语言都有默认实现**数组结构**

数组也很有很多缺点：

* 数组的创建通常需要申请一段**连续的内存空间**（一整块的内存），并且大小是固定的（大多数编程语言数组都是固定的），所以当当前数组**不能满足容量需求**时，需要**扩容**。（一般情况下是申请一个更大的数组，比如两倍，然后将原数组中的元素复制过去）
* 而且在数组开头或中间位置插入数据的成本很高，需要进行大量元素位移
* 尽管我们已经学过JavaScript的Array类方法可以帮助我们做这些事，但背后的原理依然是这样。

#### 2.链表的优势

> 要存储多个元素，另外一个选择就是**链表**
>
> 不同于数组，链表中的元素在内存中**不必是连续的空间**
>
> 链表的每一个元素由一个存储**元素本身的节点**和一个**指向下一个元素的引用**（有些语言称为指针或者连接）组成。

相对于数组，链表有一些**优点**：

* 内存空间不是必须连续的，可以充分利用计算机的内存，实现灵活的**内存动态管理**
* 链表不必再创建时就**确定大小**，并且大小可以**无限延伸**下去
* 链表在**插入和删除**数据时，**时间复杂度**可以达到O(1).相对数组效率高很多。

相对于数组，链表有一些**缺点**：

* 链表访问任何一个位置的元素时，都需要**从头开始访问**，无法跳过第一个元素访问任何一个元素
* 无法通过下标直接访问元素，需要从头一个个访问，直到找到对应的元素。

#### 3.链表常见操作

链表中常见操作：

* append(element): 向列表尾部添加一个新的项
* insert(position, element): 向列表的特定位置插入一个新的项
* get(position):获取对应位置的元素
* indexOf(element): 返回元素在列表中的索引。如果列表中没有该元素则返回-1
* update(position): 修改某个位置的元素
* removeAt(position): 从列表中特定位置移除一项
* remove（element）：从列表中移除一项
* isEmpty（）：如果链表中不包含任何元素，返回true，如果链表长度大于0则返回false
* size（）：返回链表包含的元素个数，与数组的length属性类似
* toString（）：由于列表项使用了Node类，就需要重写继承自JavaScript对象默认的toString方法，让其只输出元素的值 

### 四、集合结构

----

#### 1.集合常见操作

* add(value): 向集合添加一个新的项
* remove(value): 从集合移除一个值
* has(value): 如果值在集合中，返回true，否则返回false
* clear(): 移除集合中的所有项。
* size(): 返回集合所包含元素的数量，与数组的length属性类似。
* values(): 返回一个包含集合中所有值的数组
* 其他方法

#### 2.集合间操作

* 并集：对于给定的两个集合，返回一个包含两个集合中所有元素的新集合
* 交集：对于给定的两个集合，返回一个包含两个集合中共有元素的新集合
* 差集：对于给定的两个集合，在一个就不再另外一个集合里面
* 子集：验证一个给定集合是否是另一个集合的子集

### 五、哈希表

----

#### 1.哈希表介绍

* 哈希表通常基于**数组**进行实现的，但是相对于数组，它具有很多的优势：
  * 可以提供非常快速的**插入-删除-查找操作**
  * 无论多少数据，插入和删除值需要接近常量的时间：即O(1)的时间级，实际上只需要几个机器指令即可完成
  * 哈希表的速度比树还要快，基本可以瞬间查找到想要的元素
  * 哈希表相对于树来说编码容易的多
* 数组的**不足**
  1. 数组进行插入操作时，效率比较低
  2. 数组进行查找操作的效率
     1. 如果是基于索引进行查找操作效率非常高
     2. 基于内容查找（比如name=‘ant’）非常低
  3. 数组进行删除操作，效率也不高

* 哈希表相对数组的缺点：
<<<<<<< HEAD
  * 哈希表中的数据是**没有顺序**的，所以不能以一种固定的方式（比如从小到大）来遍历其中元素。
  * 通常情况下，哈希表中的key是**不允许重复**，不能放置相同的key，用于保存不同的元素。

* 哈希表的一些概念

  * **哈希化**:将大数字转化成数组范围内下标的过程，称之为**哈希化**
  * **哈希函数**：通常我们将单词转成大数字，大数字在进行哈希化的代码实现放在一个函数中，这个函数我们称之为**哈希函数**

  * **哈希表**：最终将数据插入到的这个数组，对整个**结构的封装**，称之为**哈希表**

#### 2.哈希表扩容

##### 1. 为什么需要扩容？

* 目前，我们是将所有的数据项放在**长度为7的数组**中的
* 因为我们使用的是**链地址法，loadFactor**可以大于1，所以这个哈希表可以无限制的插入新数据
* 但是，随着**数据量的增多**，每一个index对应的bucket会越来越多，也就造成**效率的降低**
* 所以，在合适的时候对数组进行**扩容**，比如扩容两倍

##### 2. 如何进行扩容？

* 扩容可以简单的将容量增大两倍
* 但是这种情况下，所有的数据项**一定要同时进行修改**（重新调用哈希函数，来获取到不同的位置）
* 比如hashCode=12的数据项，在length=8的时候，index=4在长度为16的时候呢？index=12
* 这是一个**耗时的过程**，但是如果**数组需要扩容**，那么这个过程是**必要的**

##### 3. 什么情况下扩容呢？

* 比较常见的情况是**loadFactor>0.75**的时候进行扩容
* 比如Java的哈希表就是在装填因子大于0.75的时候，对哈希表进行扩容

##### 4. 容量质数

* 之前我们说了我们的容量最好是质数，我们再扩容或缩容的时候都应该判断一下我们新的容量是否是质数，如果不是就去找最近的质数
* 什么是质数？**质数**：只能被1和自己整除，不能被2-num-1之间的数整除

### 六、树

##### 1. 什么是树？

##### 2. 树的优点

###### 1. 数组优缺点：

1. 优点：
   1. 数组的主要优点是**下标值访问**效率会很高
   2. 但是如果我们希望根据元素来查找对应位置呢？
   3. 比较好的方式是先对数组进行**排序**，再进行**二分查找**

2. 缺点：
   1. 需要先对数组进行**排序**，生成**有序数组**，才能提高查找效率
   2. 另外数组在插入和删除数据时，需要有大量的**位移操作**（插入到首位或者中间位置的时候），效率很低

###### 2. 链表优缺点：

1. 优点：
   1. 链表的插入和删除操作效率都很高
2. 缺点：
   1. **查找**效率很低，需要从头开始依次访问链表中的每个数据项，直到找到
   2. 而且即使插入和删除操作效率很高，但是如果要插入和删除中间位置的数据，还是需要从头开始找对应的数据

###### 3. 哈希表优缺点：

1. 优点：
   1. 哈希表的插入、查询、删除效率都很高
2. 缺点：
   1. **空间利用率不高**，底层使用的是数组，并且某些单元是没有被利用的
   2. 哈希表中的元素是**无序**的，不能按照固定的顺序来遍历哈希表中的元素
   3. 不能快速的找出哈希表中**最大值或者最小值**这些特殊的值

###### 4. 树结构：

1. 每种数据结构都有自己特定的应用场景
2. 树确实也综合了上面的数据结构的优点（当然优点不足于盖过其他数据结构，比如效率一般情况下没有哈希表高）
3. 并且也弥补了上面数据结构的缺点
4. 未来模拟某些场景，我们使用树结构会更加方便
5. 因为树结构的非线性，可以表示一对多的关系。 比如：文件的目录

##### 5. 树的术语

	1. 节点的度（Degree）：节点的**子树个数**
 	2. 树的度：树的所有节点中**最大的度数**
 	3. 叶节点（Leaf）：**度为0的节点**（也称为叶子节点）
 	4. 父节点（Parent）：有子树的节点是其子树的根节点的父节点
 	5. 子节点（Child）：若A节点是B节点的父节点，则称B节点是A节点的子节点；子节点也称孩子节点
 	6. 兄弟节点（Siling）：具有同一父节点的各节点彼此是兄弟节点
 	7. 路径和路径长度：从节点n1到nk的路径为一个节点序列n1，n2,...,nk,ni是ni+1的父节点。路径所包含边的个数为路径的长度
 	8. 节点的层数（Level）：规定**根节点在1层**，其它任一节点的层数是其父节点的层数加1
 	9. 树的深度（Depth）：树中所有节点中的**最大层次**是这棵树的深度

### 七、二叉树

二叉树示意图：

~~~~reStructuredText
	A
   / \
  B   c
 / \ / \
D  E F  G
~~~~



#### 1. 什么是二叉树？

		1. 二叉树可以为空，也可以没有节点
  		2. 若不为空，则它是由根节点和称为其左子树TL和右子树TR的两个不相交的二叉树组成

#### 2. 二叉树的特性

* 一个二叉树第i层的最大节点树为：2^(i-1),i>=1;
* 深度为k的二叉树有最大节点总数为：2^k -1 ,k >= 1;
* 对任何非空二叉树T，若n0表示叶节点的个数，n2是度为2的非叶节点个数，那么两者满足关系n0 = n2 + 1

#### 3.二叉树最常见的表示方法还是链表
=======
  * 哈希表中的数据是**没有顺序**的，所以不能以一种固定的方式（比如从小到大）来遍历其中元素
  * 通常情况下，哈希表中的key是**不允许重复**，不能放置相同的key，用于保存不同的元素。

#### 2.优秀的哈希函数

> 好的哈希函数应该尽可能让计算的过程变得简单，提高计算的速度
>
> 1. 哈希表的主要**优点是它的速度**，所以在速度上满足不了，那么久没有设计的意义
> 2. 提高速度的一个方法就是让哈希函数中**尽量少的有乘法和除法**，因为他们是**性能比较低**的方法

##### 2.1 好的哈希函数具备哪些优点？

* ##### **快速的计算**

  * 哈希表的优势就在于效率，所以快速获取到对应的hashCode非常重要
  * 我们需要通过快速的计算来获取到元素对应的hashCode

* **均匀的分布**

  * 哈希表中，无论是链地址法还是开放地址法，当多个元素映射到同一位置的时候，都会影响效率
  * 所以，优秀的哈希函数应该尽可能将元素映射到不同的位置，让元素在哈希表中均匀分布

### 六、二叉树

 	1. 二叉树最常见的方式还是使用链表存储
      	1. 1 每个节点封装成一个Node，Node中包含存储的数据，左节点的引用和右节点的引用。

##### 2.什么是二叉搜索树？

> 二叉搜索树（BST， Binary Search Tree）,也称为二叉排序树

* 二叉搜索树是一颗二叉树，可以为空；
* 如果不为空，满足一下性质：
  * 非空左子树的所有键值小于其根节点键值。
  * 非空右子树的所有键值大于其根节点的键值。
  * 左、右子树本身也都是二叉搜索树。
* 二叉搜索树的**特点**:
  * 二叉搜索树的特点就是相对**较小的值**总是保存在**左节点**上，相对**较大的值**总是保存在**右节点**上。
  * 利用这个特性，也是二叉搜索树查询效率非常高的原因

>>>>>>> e60841e24bfe5a5fa3318b90bef90e4460710329
